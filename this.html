<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">

  <title>함수 호출 방식에 의해 결정되는 this문</title>

  <style>

  </style>
</head>

<body>


<p>
  this문 관련 사이

</p>


<script>

// 자바스크립트의 함수는 호출될 때 매개변수로 전달되는 인자값 이외에
// arguments 객체와 this를 암묵적으로 전달 받는다.

function square(number) {
  console.log(arguments);
  console.log(this);

  return number * number;
}

square(2);



// this는 인스턴스 자신을 가리키는 참조변수이다.
// this가 객체 자신에 대한 참조 값을 가지고 있다는 뜻이다.
// 주로 매개변수와 객체 자신이 가지고 있는 멤버변수명이 같을 경우 이를 구분하기 위해 사용됨
// this.name은 멤버변수를 의미하며 name은 생성자 함수가 전달받은 매개변수를 의미함.

public Class Person{
    private String name;

    public Person(String name){
        this.name = name;
    }
}



// 함수 호출 방식과 this 바인딩
// 자바스크립트의 경우 함수 호출 방식에 의해 this에 바인딩할 어던 객체가 동적으로 결정됨
// 다시말해, 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고,
// 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩 할 객체가 동적으로 결정됨

// 함수의 호출하는 방식은
// 1 함수 호출
// 2 메소드 호출
// 3 생성자 함수 호출
// 4 apply/call/bind 호출

var foo = function () {
    console.dir(this);
};

// 1. 함수 호출
  foo();  // window
  //window.foo();

// 2. 메소드 호출
  var obj = {foo: foo};
  obj.foo();  // obj

// 3. 생성자 함수 호출
  var instance = new foo(); // instance

// 4. apply/call/bind 호출
  var bar = {name: 'bar'};
  foo.call(bar);  // bar
  foo.apply(bar); //bar
  foo.bind(bar)();  // bar




// 1. 함수호출
  // 전역객체(global object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 browser-side에서는 window,
  // server-side(node.js)에서는 global 객체를 의미함

  // in browser console
  this === window // true

  // in Terminal
  node
  this === global // true

  // 전역객체는 전역 스코프를 갖는 전역변수를 프로퍼티로 소유함.
  // 글로벌 영역에서 선언한 함수는 전역객체의 프로퍼티로 접근할 수 있는 전역 변수의 메소드이다.

  var ga = 'Global variable';

  console.log(ga);
  console.log(window.ga);
  
  function foo() {
      console.log('invoked!');
  }
  window.foo();


  // 기본적으로 this는 전역객체에 바인딩됨.
  // 전역 함수는 물론이고 심지어 내부함수의 경우도 this는 외부함수가 아닌 전역객체에 바인딩됨

function foo() {
    console.log("foo's this: ", this);  // window
    function bar() {
        console.log("bar's this: ", this);  // window
    }
    bar();
}
foo();

  // 또한 메소드의 내부함수일 경우에도 this는 전역객체에 바인딩됨
  var value = 1;

  var obj = {
      value: 100,
      foo: function () {
          console.log("foo's this: ", this);  // obj
          console.log("foo's this.value: ", this.value);  // 100
          function bar() {
              console.log("bar's this: ", this);  // window
              console.log("bar's this.value: ", this.value);  // 1
          }
          bar();
      }
  };
  obj.foo();


  // 내부함수는 일반 함수, 메소드, 콜백함수 어디에서 선언되었든 관게없이 this는 전역객체를 바인딩한다.
  // 내부함수의 this가 전역객체를 참조하는 것을 회피하는 방법은 다음과 같다.
  var value = 1;

  var obj = {
      value: 100,
      foo: function () {
          var that = this;  // workaround : this === obj

          console.log("foo's this: ", this);  // obj
          console.log("foo's this.value: ", this.value);  // 100
          function bar() {
              console.log("bar's this: ", this);  // window
              console.log("bar's this.value: ", this.value);  // 1

              console.log("bar's that: ",  that); // obj
              console.log("bar's that.value: ", that.value); // 100
          }
          bar();
      }
  };

  obj.foo();







</script>

</body>
</html>